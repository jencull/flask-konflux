apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: export-pipeline-logs
  labels:
    app.kubernetes.io/managed-by: tekton
spec:
  description: |
    Gathers all logs from a completed Tekton PipelineRun, packages them into a simple
    OCI artifact (tar.gz blob) and pushes it to a specified Quay repository.
  params:
    - name: quay-repo
      type: string
      description: The base Quay repository path (e.g., quay.io/org/repo).
    - name: pipeline-run-name
      type: string
      description: The name of the PipelineRun whose logs should be collected.
    - name: namespace
      type: string
      description: The namespace where the PipelineRun was executed.
      default: "$(context.pipelineRun.namespace)"
    - name: artifact-credentials-secret
      type: string
      description: Name of the secret containing registry credentials (must match what secure-push-oci expects, e.g., 'oci-storage-dockerconfigjson' key).
  results:
    - name: LOG_ARTIFACT_TAG
      description: The specific tag generated for the log artifact.
  workspaces:
    - name: shared-data
      description: Workspace for log archiving and image creation files.
  steps:
    - name: fetch-and-prepare-logs
      image: registry.redhat.io/openshift4/ose-cli:latest
      workingDir: $(workspaces.shared-data.path)
      env:
        - name: PR_NAME
          value: "$(params.pipeline-run-name)"
        - name: PR_NAMESPACE
          value: "$(params.namespace)"
        - name: HOME
          value: /tmp
      script: |
        #!/bin/bash
        set -euo pipefail

        microdnf install jq -y || {
          echo "Warning: microdnf failed. Attempting dnf install."
          dnf install jq -y
        }
        
        LOG_FILENAME="logs.txt"
        ARCHIVE_FILENAME="logs.tar.gz"
        IMAGE_TAG="$(params.pipeline-run-name)-$(date +%Y%m%d%H%M%S)-logs"

        echo "Starting log export for PipelineRun: ${PR_NAME}"
        
        CMD="oc"
        if ! command -v oc &> /dev/null; then
          CMD="kubectl"
        fi

        set -x 
        
        ${CMD} logs --namespace "${PR_NAMESPACE}" pipelinerun/"${PR_NAME}" --all > "${LOG_FILENAME}" 2>&1 || {
            echo "Primary log retrieval failed, attempting fallback for older clusters by tasks..."
            ${CMD} get pr "${PR_NAME}" -o json -n "${PR_NAMESPACE}" | jq -r '.status.childReferences[].name' | while read taskrun; do
              ${CMD} logs --namespace "${PR_NAMESPACE}" taskrun/"${taskrun}" --all >> "${LOG_FILENAME}" 2>&1 || true
            done
        }

        set +x
        
        echo ""
        echo "=== ARCHIVE CREATION ==="
        if [ -s "${LOG_FILENAME}" ]; then
            echo "✓ Successfully fetched logs."
            echo "Log file size: $(stat -f%z "${LOG_FILENAME}" 2>/dev/null || stat -c%s "${LOG_FILENAME}" 2>/dev/null || echo "unknown") bytes"
            
            echo "Creating compressed archive: ${ARCHIVE_FILENAME}"
            tar -czf "${ARCHIVE_FILENAME}" "${LOG_FILENAME}" || {
              echo "✗ ERROR: Failed to create archive"
              exit 1
            }
            
            if [ -f "${ARCHIVE_FILENAME}" ]; then
              ARCHIVE_SIZE=$(stat -f%z "${ARCHIVE_FILENAME}" 2>/dev/null || stat -c%s "${ARCHIVE_FILENAME}" 2>/dev/null || echo "unknown")
              echo "✓ Created compressed archive: ${ARCHIVE_FILENAME} (${ARCHIVE_SIZE} bytes)"
            else
              echo "✗ ERROR: Archive file was not created"
              exit 1
            fi
            
            echo ""
            echo "=== WRITING ARTIFACT TAG ==="
            echo "Tag value: ${IMAGE_TAG}"
            
            # Write the tag to the Tekton result
            RESULT_PATH="$(results.LOG_ARTIFACT_TAG.path)"
            echo "Writing tag to Tekton result path: ${RESULT_PATH}"
            if [ -n "${RESULT_PATH}" ]; then
              echo -n "${IMAGE_TAG}" > "${RESULT_PATH}" || {
                echo "✗ ERROR: Failed to write to result path: ${RESULT_PATH}"
                echo "Checking if directory exists..."
                ls -la "$(dirname "${RESULT_PATH}")" 2>&1 || true
                exit 1
              }
              if [ -f "${RESULT_PATH}" ]; then
                echo "✓ Successfully wrote tag to result path"
                echo "Result file contents: $(cat "${RESULT_PATH}")"
              else
                echo "✗ ERROR: Result file was not created"
                exit 1
              fi
            else
              echo "⚠ WARNING: Result path is empty, skipping result write"
            fi
            
            # Also write to a file for use in the next step
            echo "Writing tag to image-tag.txt for next step"
            echo -n "${IMAGE_TAG}" > image-tag.txt || {
              echo "✗ ERROR: Failed to write to image-tag.txt"
              exit 1
            }
            if [ -f "image-tag.txt" ]; then
              echo "✓ Successfully wrote tag to image-tag.txt"
              echo "Tag file contents: $(cat image-tag.txt)"
              echo "Tag file size: $(stat -f%z image-tag.txt 2>/dev/null || stat -c%s image-tag.txt 2>/dev/null || echo "unknown") bytes"
            else
              echo "✗ ERROR: image-tag.txt was not created"
              exit 1
            fi
            
            echo ""
            echo "=== STEP COMPLETE ==="
            echo "Files in working directory:"
            ls -la || true
        else
            echo "✗ WARNING: Log file is empty. Skipping artifact creation."
            exit 0
        fi

    - name: push-log-artifact
      image: registry.redhat.io/openshift4/ose-cli:latest
      workingDir: $(workspaces.shared-data.path)
      env:
        - name: HOME
          value: /tmp
        - name: QUAY_REPO
          value: $(params.quay-repo)
      script: |
        #!/bin/bash
        set -euo pipefail
        
        # Read the tag from the file created in the previous step
        echo "=== READING ARTIFACT TAG ==="
        if [ -f "image-tag.txt" ]; then
          IMAGE_TAG=$(cat image-tag.txt)
          echo "✓ Read tag from image-tag.txt: ${IMAGE_TAG}"
        else
          echo "✗ ERROR: image-tag.txt not found!"
          exit 1
        fi
        OCI_REF="${QUAY_REPO}:${IMAGE_TAG}"
        echo "✓ OCI reference: ${OCI_REF}"
        echo ""
        
        # Install oras if not available
        echo "=== CHECKING ORAS INSTALLATION ==="
        if command -v oras &> /dev/null; then
          ORAS_PATH=$(command -v oras)
          ORAS_VERSION=$(oras version 2>/dev/null || echo "unknown")
          echo "✓ oras already installed at: ${ORAS_PATH}"
          echo "✓ oras version: ${ORAS_VERSION}"
        else
          echo "✗ oras not found, installing..."
          ORAS_VERSION="1.1.0"
          echo "Downloading oras v${ORAS_VERSION}..."
          curl -LO "https://github.com/oras-project/oras/releases/download/v${ORAS_VERSION}/oras_${ORAS_VERSION}_linux_amd64.tar.gz" || {
            echo "✗ Failed to download oras"
            exit 1
          }
          echo "✓ Downloaded oras tarball"
          tar -xzf "oras_${ORAS_VERSION}_linux_amd64.tar.gz" -C /usr/local/bin/ oras || {
            echo "✗ Failed to extract oras"
            exit 1
          }
          echo "✓ Extracted oras to /usr/local/bin/oras"
          chmod +x /usr/local/bin/oras
          echo "✓ Set executable permissions"
          rm "oras_${ORAS_VERSION}_linux_amd64.tar.gz"
          echo "✓ Cleaned up tarball"
          if command -v oras &> /dev/null; then
            echo "✓ oras installation verified"
          else
            echo "✗ oras installation failed - command not found after install"
            exit 1
          fi
        fi
        echo ""
        
        # Set up authentication with verbose logging
        echo "=== AUTHENTICATION SETUP ==="
        SECRET_NAME="$(params.artifact-credentials-secret)"
        echo "Secret name: ${SECRET_NAME}"
        echo "Quay repo: ${QUAY_REPO}"
        mkdir -p "$HOME/.docker"
        echo "Created .docker directory at: $HOME/.docker"
        
        AUTH_METHOD="none"
        
        # Try multiple authentication methods with detailed logging
        echo ""
        echo "--- Method 1: Checking Tekton mounted credentials ---"
        if [ -f "/tekton/creds/.docker/config.json" ]; then
          echo "✓ Found /tekton/creds/.docker/config.json"
          cp /tekton/creds/.docker/config.json "$HOME/.docker/config.json"
          if [ -f "$HOME/.docker/config.json" ] && [ -s "$HOME/.docker/config.json" ]; then
            echo "✓ Successfully copied Tekton mounted credentials"
            AUTH_METHOD="tekton-mounted"
          else
            echo "✗ Failed to copy credentials file"
          fi
        else
          echo "✗ /tekton/creds/.docker/config.json not found"
        fi
        
        # Only try other methods if the first one didn't work
        if [ "$AUTH_METHOD" = "none" ]; then
          echo ""
          echo "--- Method 2: Checking for oc command ---"
          if command -v oc &> /dev/null; then
            echo "✓ oc command found at: $(command -v oc)"
            echo "Attempting to get secret '${SECRET_NAME}' using oc..."
            if oc get secret "${SECRET_NAME}" >/dev/null 2>&1; then
              echo "✓ Secret '${SECRET_NAME}' exists"
              oc get secret "${SECRET_NAME}" -o jsonpath='{.data.\.dockerconfigjson}' | base64 -d > "$HOME/.docker/config.json" 2>&1
              if [ $? -eq 0 ] && [ -f "$HOME/.docker/config.json" ] && [ -s "$HOME/.docker/config.json" ]; then
                echo "✓ Successfully retrieved secret using oc"
                AUTH_METHOD="oc-secret"
              else
                echo "✗ Failed to decode or write secret data"
                echo "Error output: $(oc get secret "${SECRET_NAME}" -o jsonpath='{.data.\.dockerconfigjson}' 2>&1 | head -c 100)"
              fi
            else
              echo "✗ Secret '${SECRET_NAME}' not found or not accessible"
            fi
          else
            echo "✗ oc command not found"
          fi
        fi
        
        if [ "$AUTH_METHOD" = "none" ]; then
          echo ""
          echo "--- Method 3: Checking for kubectl command ---"
          if command -v kubectl &> /dev/null; then
            echo "✓ kubectl command found at: $(command -v kubectl)"
            echo "Attempting to get secret '${SECRET_NAME}' using kubectl..."
            if kubectl get secret "${SECRET_NAME}" >/dev/null 2>&1; then
              echo "✓ Secret '${SECRET_NAME}' exists"
              kubectl get secret "${SECRET_NAME}" -o jsonpath='{.data.\.dockerconfigjson}' | base64 -d > "$HOME/.docker/config.json" 2>&1
              if [ $? -eq 0 ] && [ -f "$HOME/.docker/config.json" ] && [ -s "$HOME/.docker/config.json" ]; then
                echo "✓ Successfully retrieved secret using kubectl"
                AUTH_METHOD="kubectl-secret"
              else
                echo "✗ Failed to decode or write secret data"
              fi
            else
              echo "✗ Secret '${SECRET_NAME}' not found or not accessible"
            fi
          else
            echo "✗ kubectl command not found"
          fi
        fi
        
        echo ""
        echo "=== AUTHENTICATION RESULT ==="
        if [ -f "$HOME/.docker/config.json" ] && [ -s "$HOME/.docker/config.json" ]; then
          echo "✓ Authentication file exists: $HOME/.docker/config.json"
          FILE_SIZE=$(stat -f%z "$HOME/.docker/config.json" 2>/dev/null || stat -c%s "$HOME/.docker/config.json" 2>/dev/null || echo "unknown")
          echo "✓ File size: ${FILE_SIZE} bytes"
          
          # Validate it's valid JSON
          if command -v jq &> /dev/null; then
            if jq empty "$HOME/.docker/config.json" 2>/dev/null; then
              echo "✓ Authentication file is valid JSON"
              # Check if it has auths section
              if jq -e '.auths' "$HOME/.docker/config.json" >/dev/null 2>&1; then
                AUTH_COUNT=$(jq '.auths | length' "$HOME/.docker/config.json" 2>/dev/null || echo "0")
                echo "✓ Found ${AUTH_COUNT} registry auth entry/entries"
              else
                echo "⚠ WARNING: No 'auths' section found in config.json"
              fi
            else
              echo "✗ ERROR: Authentication file is not valid JSON!"
              jq empty "$HOME/.docker/config.json" 2>&1 | head -5
            fi
          else
            echo "⚠ jq not available, skipping JSON validation"
          fi
          
          echo "✓ Authentication method used: ${AUTH_METHOD}"
          export DOCKER_CONFIG="$HOME/.docker"
          echo "✓ DOCKER_CONFIG set to: $DOCKER_CONFIG"
        else
          echo "✗ ERROR: No valid authentication file found!"
          echo "✗ Authentication method: ${AUTH_METHOD}"
          echo "✗ Cannot proceed without authentication"
          echo "Available files in $HOME/.docker:"
          ls -la "$HOME/.docker/" 2>/dev/null || echo "Directory does not exist"
          exit 1
        fi
        echo "=============================="
        echo ""
        
        # Push the tar.gz file as an OCI artifact
        echo "=== PUSHING ARTIFACT ==="
        if [ ! -f "logs.tar.gz" ]; then
          echo "✗ ERROR: logs.tar.gz not found in working directory!"
          echo "Current directory: $(pwd)"
          echo "Files in directory:"
          ls -la || true
          exit 1
        fi
        FILE_SIZE=$(stat -f%z logs.tar.gz 2>/dev/null || stat -c%s logs.tar.gz 2>/dev/null || echo "unknown")
        echo "✓ Found logs.tar.gz (${FILE_SIZE} bytes)"
        echo "Pushing to: ${OCI_REF}"
        echo "Artifact type: application/vnd.logs.tar+gzip"
        echo ""
        
        # Test registry connectivity first
        echo "--- Testing registry connectivity ---"
        REGISTRY_HOST=$(echo "${QUAY_REPO}" | cut -d'/' -f1)
        echo "Registry host: ${REGISTRY_HOST}"
        if command -v timeout &> /dev/null; then
          if timeout 10 bash -c "echo > /dev/tcp/${REGISTRY_HOST}/443" 2>/dev/null; then
            echo "✓ Registry port 443 is reachable"
          else
            echo "⚠ Warning: Cannot reach registry on port 443 (may still work with different port)"
          fi
        else
          echo "⚠ timeout command not available, skipping connectivity test"
        fi
        echo ""
        
        # Function to push with timeout
        push_with_timeout() {
          local timeout_seconds=300  # 5 minutes
          local start_time=$(date +%s)
          
          echo "Starting push (timeout: ${timeout_seconds}s)..."
          echo "Command: oras push --no-tty --artifact-type application/vnd.logs.tar+gzip ${OCI_REF} logs.tar.gz:application/vnd.logs.tar+gzip"
          echo ""
          
          # Run oras push in background and monitor
          oras push --no-tty \
            --artifact-type "application/vnd.logs.tar+gzip" \
            "${OCI_REF}" \
            "logs.tar.gz:application/vnd.logs.tar+gzip" &
          local push_pid=$!
          
          # Monitor the process
          while kill -0 $push_pid 2>/dev/null; do
            local current_time=$(date +%s)
            local elapsed=$((current_time - start_time))
            
            if [ $elapsed -ge $timeout_seconds ]; then
              echo ""
              echo "✗ ERROR: Push operation timed out after ${timeout_seconds} seconds"
              kill -9 $push_pid 2>/dev/null || true
              return 1
            fi
            
            # Print progress every 30 seconds
            if [ $((elapsed % 30)) -eq 0 ] && [ $elapsed -gt 0 ]; then
              echo "[${elapsed}s elapsed] Push still in progress..."
            fi
            
            sleep 2
          done
          
          # Wait for the process to finish and get exit code
          wait $push_pid
          return $?
        }
        
        # Try to use timeout command if available, otherwise use our function
        if command -v timeout &> /dev/null; then
          echo "Using timeout command for push operation..."
          timeout 300 oras push --no-tty \
            --artifact-type "application/vnd.logs.tar+gzip" \
            "${OCI_REF}" \
            "logs.tar.gz:application/vnd.logs.tar+gzip" || {
            EXIT_CODE=$?
            if [ $EXIT_CODE -eq 124 ]; then
              echo ""
              echo "✗ ERROR: Push operation timed out after 300 seconds"
            else
              echo ""
              echo "✗ ERROR: Failed to push artifact to ${OCI_REF} (exit code: $EXIT_CODE)"
            fi
            echo "Check authentication and network connectivity"
            exit 1
          }
        else
          echo "timeout command not available, using custom timeout wrapper..."
          push_with_timeout || {
            echo ""
            echo "✗ ERROR: Failed to push artifact to ${OCI_REF}"
            echo "Check authentication and network connectivity"
            exit 1
          }
        fi
        
        echo ""
        echo "✓ Successfully pushed log artifact to ${OCI_REF}"
        echo "=== PUSH COMPLETE ==="
